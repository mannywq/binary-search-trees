# frozen_string_literal: true

class Node
  attr_accessor :data, :left, :right

  include Comparable

  def initialize(value = 0)
    @data = value
    @left = nil
    @right = nil
  end

  def <=>(other)
    @data <=> other.data
  end
end

class Tree
  attr_accessor :root, :nodes

  def initialize(node = nil)
    @root = node
    @nodes = 0
    @parent = nil
  end

  def build_tree(array)
    return nil if array.empty?
    return array if array.length < 2

    # puts array
    mid = (array.length / 2)
    node = Node.new(array[mid])
    @root = node if @root.nil?

    node.left = build_tree(array[0..mid - 1])
    node.right = build_tree(array[mid + 1..-1])

    node
  end

  def find(value)
    start = @root

    queue = []

    queue.append(start)

    until queue.empty?

      node = queue.shift
      return node if node.data == value

      queue.append(node.left) unless node.left.nil?
      queue.append(node.right) unless node.right.nil?

      # puts "Queue value now is #{queue.length}"

    end

    nil
  end

  def insert(root, value)
    if root.nil?
      puts "Creating new node with value #{value}"
      return Node.new(value)
    end

    if root.data == value
      puts "#{value} exists - returning node"
      return root
    elsif root.data < value
      puts 'Current node is less than value - Looking right'
      root.right = insert(root.right, value)
    else
      puts 'Current node is higher than value - Looking left'
      root.left = insert(root.left, value)
    end

    root
  end

  def delete(node, value)
    return node if node.nil? # Node not found

    current = node
    while !current.nil? && current.data != value
      current = if current.data < node.data
                  delete(current.left, value)
                else
                  delete(current.right, value)
                end

      if current.nil?
        puts "Value #{value} not found in tree"
        return node
      end

    end

    puts "Found node at #{current}"

    # Check for no children
    if current.left.nil? && current.right.nil?

      current = nil

    # Check for one child
    elsif current.left.nil?
      puts 'Right child exists - swapping values and deleting'

      temp = current.right

      current.data = temp.data

      current.right = nil
    elsif current.right.nil?
      puts 'Left child exists - swapping values and deleting'

      temp = current.left

      current.data = temp.data

      current.left = nil

      # Check for two children
    else
      puts 'Node has two children - looking for min successor'

      temp = find_min(current.right)

      current.data = temp.data

      temp = nil

    end
  end

  def find_min(node)
    node = node.left until node.left.nil?
    puts "Minimum of right tree is #{node}"
    node
  end

  def handle_two_children(node)
    parent, successor = find_in_order_successor(node)

    node.data = successor.data

    if parent == node
      parent.right = successor.right
    else
      parent.left = successor.right
    end
  end

  def handle_child(parent, node)
    child = node.left || node.right

    if parent.nil?

      @root = child
    elsif parent.left == node
      parent.left = child
    else
      parent.right = child
    end
  end

  def find_in_order_successor(node)
    return node unless node.left

    parent = node.left

    successor = node.left

    while successor.left

      parent = successor
      successor = successor.left
    end

    [parent, successor]
  end

  def in_order
    return if @root.nil?

    node = @root

    in_order(node.left) if node.left
    puts "#{node.data} "
    in_order(node.right) if node.right
  end

  def pre_order(node)
    puts node.data
    pre_order(node.left) if node.left
    in_order(node.right) if node.right
  end

  def print_tree(node = @root, prefix = '', is_left = true)
    return if node.nil?

    print_tree(node.left, "#{prefix}#{is_left ? '│   ' : '    '}", true) if node.left
    puts "#{prefix}#{is_left ? '└── ' : '┌── '}#{node.data}"
    print_tree(node.right, "#{prefix}#{is_left ? '    ' : '│   '}", false) if node.right
  end
end

arr = Array.new(20) { rand(1..40) }

sorted = arr.uniq.sort

tree = Tree.new

tree.build_tree(sorted)

puts tree.root

tree.in_order
